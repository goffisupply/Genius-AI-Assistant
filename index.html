<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Assistant</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.5.4/dist/speech-commands.min.js"></script>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f7fb;
            color: #333;
        }

        .app {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: #2c3e50;
        }

        main {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .status-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .status-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #ccc;
            margin-right: 10px;
        }

        .status-indicator.active {
            background-color: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        .status-text {
            font-size: 16px;
            font-weight: 500;
        }

        .toggle-button {
            display: block;
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background-color: #3498db;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 20px;
        }

        .toggle-button:hover {
            background-color: #2980b9;
        }

        .toggle-button.running {
            background-color: #e74c3c;
        }

        .toggle-button.running:hover {
            background-color: #c0392b;
        }

        .conversation {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            min-height: 100px;
        }

        .question-container, .response-container {
            margin-bottom: 15px;
        }

        .question-container h3, .response-container h3 {
            margin-bottom: 5px;
            color: #2c3e50;
            font-size: 16px;
        }

        .logs {
            margin-top: 20px;
        }

        .logs h3 {
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 16px;
        }

        .log-container {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            font-family: monospace;
            font-size: 14px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        footer {
            margin-top: 20px;
            text-align: center;
            color: #7f8c8d;
            font-size: 14px;
        }

        .permission-button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .permission-button:hover {
            background-color: #27ae60;
        }

        .hidden {
            display: none;
        }

        .audio-selector {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .audio-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
        }

        .audio-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: white;
            font-size: 14px;
        }

        .debug-btn {
            display: block;
            margin: 10px 0;
            padding: 8px 15px;
            background-color: #f39c12;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <h1>Voice Assistant</h1>
        </header>
        
        <main>
            <!-- Initial mic permission section -->
            <div id="permissionSection">
                <p>This app requires microphone access to function. Please click below to grant permission:</p>
                <button id="permissionButton" class="permission-button">Enable Microphone</button>
            </div>

            <!-- Main app UI (hidden initially) -->
            <div id="appUI" class="hidden">
                <div class="status-container">
                    <div id="statusIndicator" class="status-indicator"></div>
                    <div id="statusText" class="status-text">Idle</div>
                </div>
                
                <!-- Audio input device selector -->
                <div class="audio-selector">
                    <label for="audioInputSelect">Audio Input Device:</label>
                    <select id="audioInputSelect">
                        <option value="">Loading devices...</option>
                    </select>
                </div>
                
                <button id="toggleButton" class="toggle-button">Start Assistant</button>
                <button id="debugButton" class="debug-btn">Debug Audio Devices</button>
                
                <div class="conversation">
                    <div id="questionContainer" class="question-container" style="display: none;">
                        <h3>Your Question:</h3>
                        <p id="questionText"></p>
                    </div>
                    
                    <div id="responseContainer" class="response-container" style="display: none;">
                        <h3>Assistant's Response:</h3>
                        <p id="responseText"></p>
                    </div>
                </div>
                
                <div class="logs">
                    <h3>Activity Log:</h3>
                    <div id="logContainer" class="log-container"></div>
                </div>
            </div>
        </main>
        
        <footer>
            <p>This app will continue running in a background tab when minimized.</p>
        </footer>
    </div>
    
    <script>
        // Global variables
        let isRunning = false;
        let recognizer = null;
        let recognition = null;
        let audioContext = null;
        let speechSynthesis = window.speechSynthesis;
        let apiKey = "AIzaSyAS3hXY8q6HypRoIb9cN3WQbsFyBDYUNYk"; // Gemini API key
        let selectedDeviceId = ""; // Store selected audio input device
        let audioStream = null; // Store the active audio stream

        // DOM elements
        const permissionSection = document.getElementById('permissionSection');
        const permissionButton = document.getElementById('permissionButton');
        const appUI = document.getElementById('appUI');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const toggleButton = document.getElementById('toggleButton');
        const debugButton = document.getElementById('debugButton');
        const questionContainer = document.getElementById('questionContainer');
        const questionText = document.getElementById('questionText');
        const responseContainer = document.getElementById('responseContainer');
        const responseText = document.getElementById('responseText');
        const logContainer = document.getElementById('logContainer');
        const audioInputSelect = document.getElementById('audioInputSelect');

        // Request microphone permission
        permissionButton.addEventListener('click', async () => {
            try {
                // Request microphone permission
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioStream = stream; // Store the stream for later use
                
                // Hide permission section and show main UI
                permissionSection.classList.add('hidden');
                appUI.classList.remove('hidden');
                
                // Initialize audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Get available audio devices
                await getAudioInputDevices();
                
                // Add log
                addLog("Microphone access granted");
            } catch (error) {
                addLog(`Error: ${error.message}`);
                alert("Microphone access is required for this app to function.");
            }
        });

        // Get available audio input devices
        async function getAudioInputDevices() {
            try {
                // Get list of media devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // Filter for audio input devices
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                // Clear dropdown
                audioInputSelect.innerHTML = '';
                
                // Add devices to dropdown
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Microphone ${audioInputSelect.options.length + 1}`;
                    audioInputSelect.add(option);
                });
                
                // Select first device by default
                if (audioInputs.length > 0) {
                    selectedDeviceId = audioInputs[0].deviceId;
                    addLog(`Found ${audioInputs.length} audio input devices`);
                    
                    // Check if any Bluetooth devices are detected
                    const bluetoothDevices = audioInputs.filter(device => 
                        device.label.toLowerCase().includes('bluetooth') || 
                        device.label.toLowerCase().includes('airpods') ||
                        device.label.toLowerCase().includes('wireless') ||
                        device.label.toLowerCase().includes('headset'));
                    
                    if (bluetoothDevices.length > 0) {
                        addLog(`Detected Bluetooth audio devices: ${bluetoothDevices.map(d => d.label).join(', ')}`);
                        // Auto-select the first Bluetooth device
                        selectedDeviceId = bluetoothDevices[0].deviceId;
                        audioInputSelect.value = selectedDeviceId;
                    }
                } else {
                    addLog("No audio input devices found");
                }
            } catch (error) {
                addLog(`Error enumerating audio devices: ${error.message}`);
            }
        }

        // Handle audio input device selection change
        audioInputSelect.addEventListener('change', function() {
            selectedDeviceId = this.value;
            addLog(`Selected audio input device: ${this.options[this.selectedIndex].text}`);
            
            // If assistant is running, restart it to use the new device
            if (isRunning) {
                stopAssistant();
                setTimeout(() => {
                    startAssistant();
                }, 500);
            }
        });

        // Debug button to force refresh audio devices
        debugButton.addEventListener('click', async () => {
            addLog("Debug: Refreshing audio devices...");
            await getAudioInputDevices();
            
            // Force a new audio permission request to refresh device list
            try {
                if (audioStream) {
                    // Stop all tracks in the previous stream
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = { 
                    audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true 
                };
                
                audioStream = await navigator.mediaDevices.getUserMedia(constraints);
                addLog("Debug: New audio stream created with selected device");
                
                // Test audio with a beep
                playBeep(1, 500, 0.1, 1000);
            } catch (error) {
                addLog(`Debug Error: ${error.message}`);
            }
        });

        // Toggle voice assistant on/off - Fixed to properly start the assistant
        toggleButton.addEventListener('click', () => {
            addLog(`Toggle button clicked. Current state: ${isRunning ? 'Running' : 'Stopped'}`);
            
            if (isRunning) {
                stopAssistant();
            } else {
                startAssistant();
            }
        });

        // Start the voice assistant
        async function startAssistant() {
            try {
                addLog("Starting assistant...");
                isRunning = true;
                toggleButton.textContent = "Stop Assistant";
                toggleButton.classList.add("running");
                statusIndicator.classList.add("active");
                updateStatus("Initializing...");

                // Initialize the keyword spotting with selected device
                await initKeywordSpotting();
                
                // Set up speech recognition
                setupSpeechRecognition();
                
                // Initialize Web Speech API for speech synthesis
                if (!speechSynthesis) {
                    addLog("Warning: Speech synthesis not supported in this browser");
                }
                
                updateStatus("Listening for 'Genius'...");
                
                // Test with a beep to confirm assistant is running
                playBeep(1, 300, 0.1, 1500);
            } catch (error) {
                addLog(`Error starting assistant: ${error.message}`);
                stopAssistant();
            }
        }

        // Stop the voice assistant
        function stopAssistant() {
            addLog("Stopping assistant...");
            isRunning = false;
            toggleButton.textContent = "Start Assistant";
            toggleButton.classList.remove("running");
            statusIndicator.classList.remove("active");
            updateStatus("Idle");

            // Stop keyword recognition
            if (recognizer) {
                try {
                    recognizer.stopListening();
                    addLog("Keyword recognizer stopped");
                } catch (e) {
                    addLog(`Error stopping recognizer: ${e.message}`);
                }
            }
            
            // Stop speech recognition
            if (recognition) {
                try {
                    recognition.abort();
                    addLog("Speech recognition stopped");
                } catch (e) {
                    addLog(`Error stopping recognition: ${e.message}`);
                }
            }
            
            // Stop any ongoing speech
            if (speechSynthesis) {
                speechSynthesis.cancel();
            }
        }

        // Initialize keyword spotting using TensorFlow.js
        async function initKeywordSpotting() {
            try {
                addLog("Initializing keyword spotting...");
                
                // Create audio constraints with selected device
                const audioConstraints = { 
                    deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined 
                };
                
                // Request a new audio stream with the selected device
                if (audioStream) {
                    // Stop all tracks in the previous stream
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
                addLog("Audio stream created for selected device");
                
                // Load the speech commands model
                if (recognizer) {
                    try {
                        recognizer.stopListening();
                    } catch (e) {
                        // Ignore errors when stopping previous recognizer
                    }
                }
                
                recognizer = speechCommands.create('BROWSER_FFT', undefined, {
                    invokeCallbackOnNoiseAndUnknown: false,
                    includeSpectrogram: true,
                    probabilityThreshold: 0.75
                });
                
                await recognizer.ensureModelLoaded();
                addLog("Speech commands model loaded");
                
                // Start listening for keywords with selected device
                recognizer.listen(result => {
                    if (!isRunning) return;
                    
                    const scores = Array.from(result.scores);
                    const maxScore = Math.max(...scores);
                    const maxScoreIndex = scores.indexOf(maxScore);
                    const wordLabels = recognizer.wordLabels();
                    const detectedWord = wordLabels[maxScoreIndex];
                    
                    // Check if "yes" was detected (as a proxy for "Genius")
                    if (detectedWord === 'yes' && maxScore > 0.8) {
                        handleKeywordDetected();
                    }
                }, {
                    includeSpectrogram: true,
                    probabilityThreshold: 0.8,
                    overlapFactor: 0.5,
                    audioTrackConstraints: audioConstraints
                });
                
                addLog(`Listening with device: ${audioInputSelect.options[audioInputSelect.selectedIndex].text}`);
            } catch (error) {
                addLog(`Error initializing keyword spotting: ${error.message}`);
                throw error;
            }
        }

        // Set up the Web Speech API for speech recognition
        function setupSpeechRecognition() {
            // Check if browser supports speech recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                addLog("Error: Speech recognition not supported in this browser");
                return;
            }
            
            // Create recognition object
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            
            // Set device constraints if browser supports it
            if (selectedDeviceId) {
                try {
                    // For Chrome-specific implementation
                    if (typeof recognition.audioSourceId !== 'undefined') {
                        recognition.audioSourceId = selectedDeviceId;
                    } else if (typeof recognition.sourceId !== 'undefined') {
                        recognition.sourceId = selectedDeviceId;
                    } else if (typeof recognition.mediaDeviceId !== 'undefined') {
                        recognition.mediaDeviceId = selectedDeviceId;
                    }
                } catch (e) {
                    addLog("Note: This browser may not support custom microphone selection for speech recognition");
                }
            }
            
            // Set up result handler
            recognition.onresult = (event) => {
                const last = event.results.length - 1;
                const text = event.results[last][0].transcript.trim();
                
                questionText.textContent = text;
                questionContainer.style.display = 'block';
                addLog(`Question: ${text}`);
                
                // Generate response
                generateResponse(text);
            };
            
            // Set up error handler
            recognition.onerror = (event) => {
                addLog(`Speech recognition error: ${event.error}`);
                updateStatus("Listening for 'Genius'...");
                
                // Restart the recognition in case of errors
                setTimeout(() => {
                    if (isRunning) {
                        resetAfterResponse();
                    }
                }, 1000);
            };
            
            // Set up end handler
            recognition.onend = () => {
                addLog("Speech recognition ended");
            };
            
            addLog("Speech recognition setup complete");
        }

        // Handle keyword detection ("Genius")
        function handleKeywordDetected() {
            addLog("Keyword 'Genius' detected!");
            updateStatus("Say your question...");
            playBeep(1, 1000, 0.5, 1800);
            
            // Pause keyword spotting temporarily
            if (recognizer) {
                recognizer.stopListening();
            }
            
            // Start speech recognition after a short delay
            setTimeout(() => {
                if (recognition && isRunning) {
                    try {
                        recognition.start();
                        addLog("Speech recognition started");
                    } catch (e) {
                        addLog(`Error starting recognition: ${e.message}`);
                        resetAfterResponse();
                    }
                }
            }, 1000);
        }

        // Generate response from Gemini API
        async function generateResponse(prompt) {
            try {
                updateStatus("Generating response...");
                addLog("Contacting Gemini API...");
                
                // API endpoint for Gemini
                const url = `https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                
                // Prepare request body
                const requestBody = {
                    contents: [
                        {
                            parts: [
                                { text: prompt }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 800
                    }
                };
                
                // Make API request
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Extract the response text
                let responseString = "";
                if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
                    responseString = data.candidates[0].content.parts[0].text;
                } else {
                    throw new Error("Invalid response format from API");
                }
                
                // Display response
                responseText.textContent = responseString;
                responseContainer.style.display = 'block';
                addLog(`Response received: ${responseString.substring(0, 50)}...`);
                
                // Speak the response
                speakResponse(responseString);
            } catch (error) {
                addLog(`Error generating response: ${error.message}`);
                
                // Fallback response if API fails
                const fallbackResponse = "I'm sorry, I couldn't process that request due to a connection issue or API error.";
                responseText.textContent = fallbackResponse;
                responseContainer.style.display = 'block';
                speakResponse(fallbackResponse);
            }
        }

        // Speak response using Web Speech API
        function speakResponse(text) {
            updateStatus("Speaking response...");
            
            // Check if speech synthesis is available
            if (!speechSynthesis) {
                addLog("Speech synthesis not available");
                resetAfterResponse();
                return;
            }
            
            // Create speech utterance
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0; // Normal speed
            
            // Set up end event
            utterance.onend = () => {
                resetAfterResponse();
            };
            
            // Set up error event
            utterance.onerror = (event) => {
                addLog(`Speech synthesis error: ${event.error}`);
                resetAfterResponse();
            };
            
            // Speak the text
            speechSynthesis.speak(utterance);
        }

        // Reset after response is complete
        function resetAfterResponse() {
            if (!isRunning) return;
            
            updateStatus("Listening for 'Genius'...");
            
            // Restart keyword spotting with the selected device
            if (recognizer) {
                // Create audio constraints with selected device
                const audioConstraints = {
                    deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined
                };
                
                try {
                    recognizer.listen(result => {
                        if (!isRunning) return;
                        
                        const scores = Array.from(result.scores);
                        const maxScore = Math.max(...scores);
                        const maxScoreIndex = scores.indexOf(maxScore);
                        const wordLabels = recognizer.wordLabels();
                        const detectedWord = wordLabels[maxScoreIndex];
                        
                        if (detectedWord === 'yes' && maxScore > 0.8) {
                            handleKeywordDetected();
                        }
                    }, {
                        includeSpectrogram: true,
                        probabilityThreshold: 0.8,
                        overlapFactor: 0.5,
                        audioTrackConstraints: audioConstraints
                    });
                    
                    addLog("Keyword detection restarted");
                } catch (e) {
                    addLog(`Error restarting keyword detection: ${e.message}`);
                    // Try to reinitialize completely if restarting fails
                    setTimeout(() => {
                        if (isRunning) {
                            initKeywordSpotting().catch(err => {
                                addLog(`Failed to reinitialize: ${err.message}`);
                            });
                        }
                    }, 1000);
                }
            }
        }

        // Play beep sound
        function playBeep(count = 1, duration = 700, delay = 0.1, frequency = 1800) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                let currentBeep = 0;
                
                function playNext() {
                    if (currentBeep >= count) return;
                    
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = frequency;
                    
                    const now = audioContext.currentTime;
                    gainNode.gain.setValueAtTime(0.5, now);
                    
                    oscillator.start(now);
                    oscillator.stop(now + duration / 1000);
                    
                    currentBeep++;
                    
                    // Schedule next beep
                    if (currentBeep < count) {
                        setTimeout(playNext, duration + (delay * 1000));
                    }
                }
                
                playNext();
            } catch (e) {
                addLog(`Error playing beep: ${e.message}`);
            }
        }

        // Add log entry
        function addLog(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message); // Also log to console for debugging
        }

        // Update status text
        function updateStatus(message) {
            statusText.textContent = message;
        }

        // Check for device changes (like plugging in Bluetooth headphones)
        navigator.mediaDevices.addEventListener('devicechange', async () => {
            addLog("Audio device change detected");
            await getAudioInputDevices();
            
            // If the assistant is running, consider restarting it with the new device list
            if (isRunning) {
                addLog("Restarting assistant to apply device changes");
                stopAssistant();
                setTimeout(() => {
                    startAssistant();
                }, 500);
            }
        });

        // Keep app running in background
        window.addEventListener('beforeunload', (event) => {
            if (isRunning) {
                // Show confirmation dialog to prevent accidental closing
                event.preventDefault();
                event.returnValue = "Voice assistant is still running. Are you sure you want to leave?";
            }
        });

        // Visibility change handler
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Page is visible again
                addLog("App back in foreground");
            } else {
                // Page is hidden
                addLog("App running in background");
            }
        });

        // Add initial log
        addLog("App initialized. Ready to start voice assistant.");
    </script>
</body>
</html>
